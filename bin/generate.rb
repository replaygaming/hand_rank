#!/usr/bin/env ruby
# frozen_string_literal: true

root_dir = File.expand_path '..', File.dirname(__FILE__)
lib_dir = File.join( root_dir, 'lib' )
$LOAD_PATH << lib_dir

require 'hand_rank'

module HandRank
  class Generator
    # This is one time use script!
    #
    # We can convert back rank to the hand only by pre-calculation
    # of the hands. This process takes a while, so we use only
    # the product of this calculation.
    #
    # The generator itself published here for better understanding
    # from where all this data came from. The product of the generator is
    # a ruby module.
    #
    # As the result we should get the file:
    #   `lib/hand_rank/rank_to_hand.rb`
    #
    # This module extends with `HandRank::rank_to_hand`

    RANKS_NAMES = %w[2 3 4 5 6 7 8 9 T J Q K A].freeze

    MIN_POSSIBLE_POINTS = 4097
    MAX_POSSIBLE_POINTS = 36_874

    # Calculation of base15 points, slightly changed for running in this way, but producing the same values.
    class CalculateBase15Points
      MODIFIER = 760_000

      SCORING = {
        royal_flush: 10 * MODIFIER,
        straight_flush: 8 * MODIFIER,
        four_of_a_kind: 7 * MODIFIER,
        full_house: 6 * MODIFIER,
        flush: 5 * MODIFIER,
        straight: 4 * MODIFIER,
        three_of_a_kind: 3 * MODIFIER,
        two_pairs: 2 * MODIFIER,
        one_pair: MODIFIER,
        high_card: 0,
      }

      attr_reader :cards_ranks
      attr_accessor :combination

      def initialize(card_numbers, combination)
        @combination = combination.to_sym
        @cards_ranks = card_numbers.sort.map { |c| 2 + (c - 1) / 4 }
      end

      def call
        case combination
        when :straight_flush, :straight
          5.downto(1).with_index {|v, i| histogram[i] = [v,1]} if aces_low_on_straight?(histogram)
        end

        self.combination = :royal_flush if royal_flush?

        SCORING[combination] + points_from_histogram(histogram)
      end

      def aces_low_on_straight?(histogram)
        (histogram.collect(&:first) - [14]).sort == [2, 3, 4, 5]
      end

      def royal_flush?
        combination == :straight_flush && histogram.collect(&:first).last == 10
      end

      def points_from_histogram(histogram)
        histogram.flat_map do |score|
          score[1].times.map { score[0].to_s(15) }
        end.join.to_i(15)
      end

      # Get the histogram of cards ranks as an array of arrays,
      # [[rank, count], [rank, count]...]
      # sorted by descending count, then descending rank
      #
      def histogram
        return @histogram if defined?(@histogram)

        @histogram ||= cards_ranks.reduce(Hash.new(0)) do |ranks, rank|
          ranks[rank] += 1
          ranks
        end.to_a
        @histogram.sort! { |a, b| a[1] == b[1] ? b[0] <=> a[0] : b[1] <=> a[1] }
      end
    end

    def self.call
      File.open('lib/hand_rank/rank_to_hand.rb', 'w') do |f|
        f.puts <<~HEREDOC
        # frozen_string_literal: true

        module HandRank
          # This module is generated by bin/generator.rb
          # Do not edit it manually

          RANK_TO_HAND_VALUES = #{new.generate.to_s.gsub('}, ',"},\n    ")}

          def rank_to_hand(rank)
            RANK_TO_HAND_VALUES[rank]
          end

          module_function :rank_to_hand
        end
        HEREDOC
      end
    end

    def generate
      report = (1..48).each_with_object({}) do |i1, acc|
        print_and_flush '.'
        ((i1 + 1)..49).each do |i2|
          ((i2 + 1)..50).each do |i3|
            ((i3 + 1)..51).each do |i4|
              ((i4 + 1)..52).each do |i5|
                cards_array = [i1, i2, i3, i4, i5]
                points = HandRank.get(cards_array)
                combination = HandRank.category_key(points)
                hand, ranks = process_cards(cards_array, combination)
                base_15_points = CalculateBase15Points.new(cards_array, combination).call
                acc[points] = { combination: combination, ranks: ranks, hand: hand, base_15_points: base_15_points }
              end
            end
          end
        end
      end

      # this range is the adjustment for the C code output.
      # this block will sort the report asc order by points
      (MIN_POSSIBLE_POINTS..MAX_POSSIBLE_POINTS).each_with_object({}) do |points, acc|
        next unless report[points]

        acc[points] = report[points]
      end
    end

    private

    def print_and_flush(str)
      print str
      $stdout.flush
    end

    def process_cards(cards_array, combination)
      hand = cards_array.sort.map { |c| RANKS_NAMES[(c - 1) / 4] }

      # process all unpaired combibations
      return [%w[A 2 3 4 5], %w[A 5]] if (%w[A 2 3 4 5] - hand).empty?  # special ranks for lowest straigh{, flush}
      return [hand, []] if combination == 'straight_flush' && hand.last == 'A' # royal flush
      return [hand, [hand.first, hand.last]] if %w[straight straight_flush].include?(combination)
      return [hand, [hand.last]] if %w[high_card flush].include?(combination)

      # process all paired combibations
      beauty_hand = hand.each_with_object(Hash.new { |h, k| h[k] = 0 }) { |el, acc| acc[el] += 1 }
                        .to_a
                        .sort_by { |x| [x.last, RANKS_NAMES.index(x.first.to_s)] }
                        .each_with_object([]) { |(rank, count), acc| count.times { acc.push rank } }

      case combination
      when 'one_pair', 'three_of_a_kind', 'four_of_a_kind'  then [beauty_hand, [beauty_hand[4]]]
      when 'two_pairs', 'full_house'                        then [beauty_hand, [beauty_hand[1], beauty_hand[4]]]
      else raise(RuntimeError, 'Unsupported paired combination for Holdem game.')
      end
    end
  end
end

HandRank::Generator.call
